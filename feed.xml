<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://hifuyun.com/haifuyun.github.io/</id><title>Hi!FuYun</title><subtitle>开心呢就行</subtitle> <updated>2021-07-12T00:30:42+08:00</updated> <author> <name>haifuyun</name> <uri>https://hifuyun.com/haifuyun.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://hifuyun.com/haifuyun.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="https://hifuyun.com/haifuyun.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 haifuyun </rights> <icon>/haifuyun.github.io/assets/img/favicons/favicon.ico</icon> <logo>/haifuyun.github.io/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Computer Graphics FlowMap</title><link href="https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-FlowMap/" rel="alternate" type="text/html" title="Computer Graphics FlowMap" /><published>2021-07-11T00:00:00+08:00</published> <updated>2021-07-11T00:00:00+08:00</updated> <id>https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-FlowMap/</id> <content src="https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-FlowMap/" /> <author> <name>haifuyun</name> </author> <category term="Graphics" /> <category term="Texture Effect" /> <summary> Flow map如字面意思，会流动的贴图，原理是采用两张贴图，一张展示底图，一张提供位置数据(Red、Green通道映射x、y位置)让底图采样得到位置数据叠加时间后产生位移效果，表现为流动效果 提供位移数据的贴图分为RGBA四个通道，我们绘制RG两个通道，让他们分布在我们想要改变的位置坐标上 底图 叠加效果 代码 float4 f = tex2D(flowMap, i.uv) * 2 + 1; float4 t = tex2D(testTex, i.uv + f.xy * flowIntensity + float2(0, _Time.y * 0.1)); return t; waterflowmap 水流动地图，模拟水面流动效果，其实是flowmap基础上加强版本 加强版使用淡入淡出效果，消除了贴图流动周而复始运动的假象 代码逻辑: 先设定一个时间... </summary> </entry> <entry><title>透明物体的绘制 - 混合与深度测试</title><link href="https://hifuyun.com/haifuyun.github.io/posts/%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E7%BB%98%E5%88%B6/" rel="alternate" type="text/html" title="透明物体的绘制 - 混合与深度测试" /><published>2021-07-10T00:00:00+08:00</published> <updated>2021-07-10T00:00:00+08:00</updated> <id>https://hifuyun.com/haifuyun.github.io/posts/%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E7%BB%98%E5%88%B6/</id> <content src="https://hifuyun.com/haifuyun.github.io/posts/%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E7%BB%98%E5%88%B6/" /> <author> <name>haifuyun</name> </author> <category term="Graphics" /> <category term="Blender" /> <summary> 透明物体的绘制 - 混合与深度测试 当场景出现透明和不透明物体有前后遮挡关系时，我们要让透明物体透过自身能看到后面的不透明物体时，就需要混合两者的颜色，混合公式: 混合源颜色与目标颜色 Blend SrcFactor DstFactor SrcFactor 当前渲染的物体源颜色alpha值 DstFactor 屏幕已渲染的像素底色alpha值 混合公式，这里的目标颜色alpha值用时1-源颜色alpha，这个模式称为OneMinusSrcAlpha: SrcColorRGB　* SrcFactor + DstSrcColorRGB * （1 - SrcFactor） Z-buffer 深度缓冲区 记录所有像素中当前离摄像机最近那个像素深度，像素深度就是指像素渲染的物体在坐标空间中的Z值 Frame buffer 帧(颜色)缓冲区 记录所有像素中当... </summary> </entry> <entry><title>Computer Graphics Ray Tracing</title><link href="https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-RayTracing/" rel="alternate" type="text/html" title="Computer Graphics Ray Tracing" /><published>2021-06-28T00:00:00+08:00</published> <updated>2021-06-28T00:00:00+08:00</updated> <id>https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-RayTracing/</id> <content src="https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-RayTracing/" /> <author> <name>haifuyun</name> </author> <category term="Graphics" /> <category term="Ray Tracing" /> <summary> 光线追踪中需要用到几何的知识点，在这简单描述下涉及到的一些知识点 Geometry 表现几何的多种方法: Implicit(隐性) 隐形几何方程可以表示空间中的一些点之间的关系，但是没有实际的点可以告诉你，方程如下: 很容易可以判断某一个点是否在不在表面上: x = ? y = ? z = ? 若f(x,y,z) &amp;lt; 1 在物体内 若f(x,y,z) &amp;gt; 1 在物体外 若f(x,y,z) = 1 在物体表面上 \[f(x,y,z) = x^2+y^2+z^2 = 1\] Explicit(显性) 定义一个函数，2D维度的贴图UV位置通过函数映射到3D维度坐标的面模型 Ray Tracing Whitted-Style Ray Tracing 光线追踪是指我们反向的虚拟一条从人眼出发的光线到我们看到的物体，在打到的物体上，再连... </summary> </entry> <entry><title>Computer Graphics Shading Texture</title><link href="https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-ShadingTexture/" rel="alternate" type="text/html" title="Computer Graphics Shading Texture" /><published>2021-06-24T00:00:00+08:00</published> <updated>2021-06-28T14:15:08+08:00</updated> <id>https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-ShadingTexture/</id> <content src="https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-ShadingTexture/" /> <author> <name>haifuyun</name> </author> <category term="Graphics" /> <category term="Shading Texture" /> <summary> 资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html 上一篇描述了着色的整体大概流程，这篇最后描述下着色最后一个环节，材质贴图映射的细节 一张2D贴图纹理会映射到一个3D物体表面，3D物体表面的三维坐标是怎么映射到2D贴图的二维坐标的？ 使用重心坐标(Barycentric Coordinates) 用三角形的三个顶点坐标进行内部坐标插值 \((x,y) = \alpha A + \beta B + \gamma C\) \[\alpha + \beta + \gamma = 1\] \[\alpha、\beta、\gamma加起来的总和为1，它们的占比越大越靠近对应的顶点，以此可以插值得到三角形内部所有坐标\] 当然，重心坐标不仅可以插值坐标，还可以插值其他线性变化的属性，例如颜... </summary> </entry> <entry><title>Computer Graphics Shading</title><link href="https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-Shading/" rel="alternate" type="text/html" title="Computer Graphics Shading" /><published>2021-06-23T00:00:00+08:00</published> <updated>2021-06-28T14:15:08+08:00</updated> <id>https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-Shading/</id> <content src="https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-Shading/" /> <author> <name>haifuyun</name> </author> <category term="Graphics" /> <category term="Shading" /> <summary> 资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html 在绘制像素后，我们要对其着色，着色模型使用Blinn-Phong Reflectance Model，着色的像素称点为shading point 着色点需要使用到以下参数 摄像机观察着色点方向，Viewer direction - v 物体表面法线，Surface normal - n 光照方向，Light direction - l 物体表面参数，物体颜色、物体光泽度 ，color、shininess 1.Diffuse Reflection 光照射到物体表面然后被均匀的散射都各个方向，所有观察方向的表面颜色都是一样的 那么需要思考一个问题，光照射到物体上，物体收到的光占光总能量的多少？ 答案是： 我们可以根据光线入射角度和物体表... </summary> </entry> </feed>
