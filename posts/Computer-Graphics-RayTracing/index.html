<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Computer Graphics Ray Tracing" /><meta property="og:locale" content="en_US" /><meta name="description" content="开心呢就行" /><meta property="og:description" content="开心呢就行" /><link rel="canonical" href="https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-RayTracing/" /><meta property="og:url" content="https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-RayTracing/" /><meta property="og:site_name" content="Hi!FuYun" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-06-28T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Computer Graphics Ray Tracing" /><meta name="twitter:site" content="@haifuyun" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"headline":"Computer Graphics Ray Tracing","dateModified":"2021-06-28T00:00:00+08:00","datePublished":"2021-06-28T00:00:00+08:00","url":"https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-RayTracing/","description":"开心呢就行","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-RayTracing/"},"@context":"https://schema.org"}</script><title>Computer Graphics Ray Tracing | Hi!FuYun</title><link rel="apple-touch-icon" sizes="180x180" href="/haifuyun.github.io/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/haifuyun.github.io/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/haifuyun.github.io/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/haifuyun.github.io/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/haifuyun.github.io/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Hi!FuYun"><meta name="application-name" content="Hi!FuYun"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/haifuyun.github.io/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/haifuyun.github.io/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/haifuyun.github.io/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/haifuyun.github.io/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/haifuyun.github.io/" alt="avatar" class="mx-auto"> <img src="https://pbs.twimg.com/profile_images/661212370547552257/xbqo4JqZ_400x400.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/haifuyun.github.io/">Hi!FuYun</a></div><div class="site-subtitle font-italic">Non-class'dev</div></div><ul class="w-100"><li class="nav-item"> <a href="/haifuyun.github.io/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/haifuyun.github.io/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/haifuyun.github.io/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/haifuyun.github.io/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/haifuyun.github.io/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/haifuyun" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/haifuyun" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/haifuyun.github.io/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/haifuyun.github.io/"> Posts </a> </span> <span>Computer Graphics Ray Tracing</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Computer Graphics Ray Tracing</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> haifuyun </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Jun 28, 2021, 12:00 AM +0800" prep="on" > Jun 28 <i class="unloaded">2021-06-28T00:00:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4859 words">26 min</span></div></div><div class="post-content"><hr /><p>光线追踪中需要用到几何的知识点，在这简单描述下涉及到的一些知识点</p><h4 id="geometry">Geometry</h4><p>表现几何的多种方法:</p><h5 id="implicit隐性">Implicit(隐性)</h5><p>隐形几何方程可以表示空间中的一些点之间的关系，但是没有实际的点可以告诉你，方程如下:</p><p>很容易可以判断某一个点是否在不在表面上: x = ? y = ? z = ?</p><p>若f(x,y,z) &lt; 1 在物体内</p><p>若f(x,y,z) &gt; 1 在物体外</p><p>若f(x,y,z) = 1 在物体表面上</p>\[f(x,y,z) = x^2+y^2+z^2 = 1\]<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/1.png" alt="1" /></p><h5 id="explicit显性">Explicit(显性)</h5><p>定义一个函数，2D维度的贴图UV位置通过函数映射到3D维度坐标的面模型</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/2.png" alt="2" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/3.png" alt="3" /></p><hr /><h3 id="ray-tracing">Ray Tracing</h3><h5 id="whitted-style-ray-tracing">Whitted-Style Ray Tracing</h5><p>光线追踪是指我们反向的虚拟一条从人眼出发的光线到我们看到的物体，在打到的物体上，再连接一条路径到光源，看这条路径是否能直接到达光源，没有被物体遮挡，如果到达光源，那么就表示这个物体能被光源照亮，然后我们再对这个物体进行着色。</p><p>以上过程就是光源发出光线打到一个物体再到我们眼睛的路径的反向过程.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/4.png" alt="4" /></p><p>当然，光线也有可能是光源-&gt;物体-&gt;n个物体反射-&gt;物体-&gt;眼睛这么一个路径，所以我们看到的物体可能是很多条这样不同的路径的光线汇聚而成照亮再反射到我们眼睛，因此屏幕上的一个像素的着色可以是很多条光线路径汇聚而成.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/5.png" alt="5" /></p><h4 id="ray-surface-intersection">Ray-Surface Intersection</h4><p>光-表面交点</p><p>那么，上面这个过程我们需要知道光的路径和物体表面相交是怎么计算的，就需要以下的方程:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/6.png" alt="6" /> \(r(t) =o +td\) 从光源坐标出发，往某一个方向d经过时间t的距离，这就描述来一个光线发射的射线向量</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/7.png" alt="7" /></p><h5 id="隐式表面">隐式表面</h5><p>如果光线和一个物体相交，如果有交点p，那么用上面简述过的物体几何方程与光线方程做代入，隐式的几何方程可以求某一个点是否在表面上，就有以下式子: \((r(t)-c)^2-R^2=0\) 球的定义方程(球上的一个点p到球的中心c的距离平方等于半径R平方): \((p-c)^2-R^2 = 0\) 若射线与球表面有交点，则点P等于射线r(t): \(p = r(t)\) <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/haifuyun.github.io/Users/hfy/Library/Application Support/typora-user-images/截屏2021-06-25 下午6.06.08.png" alt="截屏2021-06-25 下午6.06.08" /></p><p>求出t，根据射线方程，就可以将P点球出来</p><p>另外将光线和不同的隐式表面方程求交，就可以解出不同形状的物体交点的值</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/8.png" alt="8" /></p><h5 id="显示表面">显示表面</h5><p>光线与三角形求交，当我们知道模型表面三角形的坐标值，求与物体三角形的交点，求出与三角形相交最小的t，就是最近的那个三角形，但是这种方法计算量非常大，模型表面有非常多的三角形，速度将会非常慢</p><p>射线与模型求交，如果交点数是偶数，那就是在模型外，如果交点数是奇数，那就是在模型内</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/9.png" alt="9" /></p><p>射线与三角形求交，三角形在一个平面内，我们可以和平面求交，再判断交点是否在三角形内</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/10.png" alt="10" /></p><p>假设射线和平面有一个交点，我们知道平面法线和平面上的点，平面上任何一个点减去交点得到一个向量，若这个向量和法线垂直，表示这个向量在平面内，交点也在平面内</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/11.png" alt="11" /></p><h4 id="möller-trumbore-algorithm">Möller Trumbore Algorithm</h4><p>当然，还有更简单的方法</p><p>我们知道三角形的三个顶点，所以可以用重心坐标来描述三角形内的任何一个点，我们知道重心坐标是用alpaha、beta、gama与三个顶点坐标插值出内部任何一个点，alpha+beta+gama=1，那么就可以将将其描述为alpha，beta，gama = 1- alpha - gama，这样我们就只有两个未知参数，就可以获得如下的公式:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/12.png" alt="12" /></p><p>如果光线与三角形有交点，那么肯定满足以上公式，只要解出t、b1、b2就可以得到交点，因为O、D、P0、P1、P2都是三维向量，有三个参数，所以有三个式子，因此可以解出未知的三个参数，这样就可以直接与三角形求交，不用和面求交</p><p>但是，这依然很慢，当模型越精细，面数就越多三角行也越多</p><h3 id="光线与表面三角形求交加速">光线与表面(三角形)求交加速</h3><h5 id="bounding-volumes">Bounding Volumes</h5><p>我们如何进行求交加速呢？可以用包围盒</p><p>包围盒是包裹物体的盒子，可以理解为三个对面形成的交集</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/13.png" alt="13" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/14.png" alt="14" /></p><p>我们可以判断光线与物体的这三个对面的求交，来决定要不要和场景中的物体中的三角形求交，减少物体数量就可以减少三角形数量</p><p>我们以光线进入这三个对面的时间点来判断</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/15.png" alt="15" /></p><p>与三个对面中的每个对面都求出它们的进入的时间(最小的时间)，出去的时间(最大的时间)</p><p>获得<strong>三组</strong>的<strong>进入</strong>和<strong>出去</strong>的时间后，我们取<strong>最大</strong>的进入时间，取<strong>最小</strong>的出去时间，这段时间就是三个对面的交集，也就是光线真正进入和离开物体的时间</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/16.png" alt="16" /></p><p>关键点逻辑解释:</p><p>当光线都进入了三个对面，才进入盒子，所以取最大的进入时间</p><p>当光线离开一个对面，就离开了这个盒子，所以取最小的出去时间</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/17.png" alt="17" /></p><p>因此有以下关系:</p><p>光线离开时间 &lt; 0，光线在盒子背后</p><p>光线离开时间&gt;=0同时进入时间&lt;0，光线在盒子内部发出来的</p><p>光线进入时间小于光线离开时间，同时离开时间&gt;0，光线从外部进入盒子一段时间后离开</p><p>为什么要用和坐标轴平行的面来做包围盒？</p><p>因为求不同面的t，只要用对应面的轴分量减去光线对应轴的分量就可以很简单的求出来对应的t值，这样计算方便简单，相比较于与平面求交求t</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/18.png" alt="18" /></p><h3 id="空间划分">空间划分</h3><p>我们用AABB来包围物体来与光线求交，那也可以用AABB来加速光线和场景求交的问题，来找到空间中的物体</p><p>1.均匀的格子(早期空间划分的尝试，现在依然在一些地方使用很合适)</p><p>我们先找到一个场景，把场景的包围盒找出来，把包围盒划分成一个个格子，再找出与物体表面相交的格子</p><p>当光线从某个点发射，可能会先和某个场景盒子相交，如果和某个场景盒子相交，就有可能和盒子里的格子相交，再判断与哪些格子相交，相交的格子内部有没有物体，如果有物体再判断和物体求交</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/19.png" alt="19" /></p><p>与多少数量的格子求交也会影响判断的效率，所以有一个通用的数量来做这个加速</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/20.png" alt="20" /></p><p>这种方法对于场景中物体均匀放置时非常有效的，但是如果场景中的物体很少，空白区域很大效率就很低</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/21.png" alt="21" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/22.png" alt="22" /></p><p><strong>因此有后来的空间划分来解决这个问题</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/23.png" alt="23" /></p><p>KD-Tree使用数据结构<strong>树</strong>来划分场景，没一个场景划分成两个空间，每个空间再根据物体再划分成两个，作为这个空间的子空间，递归下去，一直到最后的子空间没有物体可以再划分</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/24.png" alt="24" /></p><p>光线从场景外侧进来，首先和最上方的节点求交，如果和节点有交点，再和节点的子节点求交，如果没有子节点了，就喝节点内部的物体求交，如此循坏递归下去，直到出了场景最下方的节点</p><p>但是，如何判定三角行与场景包围盒有交点？这个问题很难准确的解决，因为场景的物体其实都是有三角形构成，而与三角形的相交判定非常难，虽然有算法，但是不准确。另外KD-Tree划分空间，会有一个物体同时出现在不同的子节点，这样多重复不直观，人们不希望出现这样麻烦的情况</p><p>所以出现另外一种更加有效的划分方法，目前几乎都在使用的方法，物体空间划分</p><h4 id="bounding-volume-hierarchy-bvh">Bounding Volume Hierarchy (BVH)</h4><p>划分方法:</p><p>1.沿着最长的轴划分，保证划分的上下左右的物体比较均衡</p><p>2.找中间的三角形划分，保证划分的左右三角形数量比较均衡，取三角形的重心，沿x轴排序，可以用快速选择算法找出中间的物体，直到划分后的空间物体小于N(自己定义，例如5)个后停止划分</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/26.png" alt="26" /></p><p>光线与BVH求交算法伪代码</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/27.png" alt="27" /></p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
</pre><td class="rouge-code"><pre><span class="n">Intersection</span> <span class="n">BVHAccel</span><span class="o">::</span><span class="n">Intersect</span><span class="p">(</span><span class="k">const</span> <span class="n">Ray</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">Intersection</span> <span class="n">isect</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">isect</span><span class="p">;</span>
    <span class="n">isect</span> <span class="o">=</span> <span class="n">BVHAccel</span><span class="o">::</span><span class="n">getIntersection</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ray</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">isect</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Intersection</span> <span class="n">BVHAccel</span><span class="o">::</span><span class="n">getIntersection</span><span class="p">(</span><span class="n">BVHBuildNode</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ray</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">Vector3f</span> <span class="n">invDir</span> <span class="o">=</span> <span class="n">Vector3f</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="o">/</span> <span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="o">/</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">dirIsNeg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> 
        <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="c1">// TODO Traverse the BVH to find intersection</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">.</span><span class="n">IntersectP</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span><span class="n">ray</span><span class="p">.</span><span class="n">direction_inv</span><span class="p">,</span><span class="n">dirIsNeg</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Intersection</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">getIntersection</span><span class="p">(</span><span class="n">ray</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">auto</span> <span class="n">hit1</span> <span class="o">=</span> <span class="n">getIntersection</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span><span class="n">ray</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">hit2</span> <span class="o">=</span> <span class="n">getIntersection</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span><span class="n">ray</span><span class="p">);</span>

    
    <span class="k">return</span> <span class="n">hit1</span><span class="p">.</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">hit2</span><span class="p">.</span><span class="n">distance</span> <span class="o">?</span> <span class="n">hit1</span> <span class="o">:</span> <span class="n">hit2</span><span class="p">;</span>   

<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">Bounds3</span><span class="o">::</span><span class="n">IntersectP</span><span class="p">(</span><span class="k">const</span> <span class="n">Ray</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector3f</span><span class="o">&amp;</span> <span class="n">invDir</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">dirIsNeg</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division</span>
    <span class="c1">// dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], use this to simplify your logic</span>
    <span class="c1">// TODO test if ray bound intersects</span>

    <span class="kt">float</span> <span class="n">tMax_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">pMax</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDir</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">tMin_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">pMin</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDir</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">tMax_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">pMax</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDir</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">tMin_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">pMin</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDir</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">tMax_z</span> <span class="o">=</span> <span class="p">(</span><span class="n">pMax</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDir</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">tMin_z</span> <span class="o">=</span> <span class="p">(</span><span class="n">pMin</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">invDir</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirIsNeg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tMin_x</span><span class="p">;</span>
        <span class="n">tMin_x</span> <span class="o">=</span> <span class="n">tMax_x</span><span class="p">;</span>
        <span class="n">tMax_x</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirIsNeg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tMin_y</span><span class="p">;</span>
        <span class="n">tMin_y</span> <span class="o">=</span> <span class="n">tMax_y</span><span class="p">;</span>
        <span class="n">tMax_y</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirIsNeg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tMin_z</span><span class="p">;</span>
        <span class="n">tMin_z</span> <span class="o">=</span> <span class="n">tMax_z</span><span class="p">;</span>
        <span class="n">tMax_z</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="n">tExit</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">tMax_x</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">tMax_y</span><span class="p">,</span><span class="n">tMax_z</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">tEnter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">tMin_x</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">tMin_y</span><span class="p">,</span><span class="n">tMin_z</span><span class="p">));</span>
    
    <span class="k">if</span><span class="p">((</span><span class="n">tEnter</span> <span class="o">&lt;=</span> <span class="n">tExit</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tExit</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)){</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    
  <span class="p">}</span>
</pre></table></code></div></div><p>以上就是空间和物体划分的区别，这样光线与空间的求交就可以很快完成</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/28.png" alt="28" /></p><hr /><h3 id="basic-radiometry-辐射度量学">Basic radiometry (辐射度量学)</h3><p>之前的光照模型中，光的强度10并没有单位，是假设的。如果要还原真实的光照强度，我们需要知道真实世界中光精准的度量单位</p><p>Radiant Energy</p><p>光源辐射出的能量，单位焦耳</p><p>\(Q [J = Joule]\) Radiant flux (power)</p><p>单位时间上的能量，单位瓦特</p><p>考虑时间上的能量，时间越长，接受的能量就越多就越热 \(\Phi \equiv dQ [W = Watt] [lm = lumen]*\)</p><p>Radiant Intensity</p><p>单位立体角上的能量</p><p>单位立体角就是单位面积除以距离平方 \(I(\omega) \equiv d\Phi / d\omega\)</p><p>Angles and Solid Angles</p><p>立体角，在三维空间中某个球面的面积除以面积距离球心距离的平方 \(\omega = A/r^2\) <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/29.png" alt="29" /></p><p>Irradiance (power per unit area)</p><p>单位时间面积收到的能量(所有方向的光)，必须是投影后垂直于面积的光的能量 \(E(x) \equiv d \Phi(x) /dA\) <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/30.png" alt="30" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/31.png" alt="31" /></p><p>Irradiance用来定义随时间变化，单位面积上的能量的衰减，而Radiant Intensity随时间变化对应的能量是没有衰减的</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/32.png" alt="32" /></p><p>Radiance (per unit solid angle, per projected unit area)</p><p>单位立体角、单位投影面积上的能量，有两种场景</p><p>Incident Radiance</p><p>某一个单位面积收到的某一个方向进来的能量</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/33.png" alt="33" /></p><p>Exiting Radiance</p><p>某一个单位面积往某一个单位立体角上发射出去的能量</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/34.png" alt="34" /></p><p>Irradiance和Radiance的关系</p><p>求某块面积收到的能量就是对所有可能过来的方向的光的的能量进行积分求和，Irradiance其实就是所有的Radiance积分求和</p><h4 id="brdf-光反射方程">BRDF 光反射方程</h4><p>在某一小块面积上收到从某个方向进来的光， 如何计算它往四面八方某一个方向反射出去</p><p>计算不同材质收到的光往各个方向分配，如漫反射、镜面反射，BRDF就可以定义如何去分配</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/35.png" alt="35" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/36.png" alt="36" /></p><p>渲染方程经过简化，具体过程可看<a href="https://www.bilibili.com/video/BV1X7411F744?p=15">视频</a>推导过程</p><p>L 物体所有辐射出来的能量</p><p>E 光源辐射出来的能量</p><p>K 物体所有辐射出来的能量经过BRDF反射出来的能量</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/37.png" alt="37" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/38.png" alt="38" /></p><p>E 光源发射出来的能量</p><p>KE 一次反射</p><p>k2E 两次反射</p><p>光栅化中只有前两部分，后面部分是光栅化比较麻烦处理的内容:</p><p>E 光源</p><p>KE 直接光照</p><p>光线追踪可以很容易解决光线传播后面的部分，全局光照</p><p>光线追踪需要用到概率论的知识:</p><p>Probability Distribution Function (PDF)</p><p>概率密度函数</p><p>随机取一个随机变量，代入概率密度函数取得的积分面积就是取得的概率</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/haifuyun.github.io/Users/hfy/Library/Application Support/typora-user-images/截屏2021-06-28 上午12.03.37.png" alt="截屏2021-06-28 上午12.03.37" />期望</p><p>变量乘概率密度积分起来</p><h3 id="monte-carlo-integration">Monte Carlo Integration</h3><p>将无数微小的面积采样然后积分起来再求平均，就可以求的不规则函数的面积</p><p>求得的PDF为 1/ b-a</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/39.png" alt="39" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/40.png" alt="40" /></p><hr /><h3 id="path-tracing">Path Tracing</h3><p>首先因为场景中物体出了光源，自身都不发光，所以我们将渲染方程中的自发光项去掉，只考虑反射，称为反射方程</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/41.png" alt="41" /></p><p>方程就是在半球上不同方向上的积分，我们可以用蒙特卡罗积分来解这个问题</p><p>选一个着色点，随机选一个方向，就是我们的随机变量X，需要求出f(x)和PDF</p><p>f(x)就是方程</p><p>PDF就是半球表面积分之一，球面面积是4pi，半球面积是2pi，半球上某个方向立体角就是1/2pi</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/42.png" alt="42" /></p><p>根据蒙特卡罗积分就可以将方程转化为如下求和式</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/43.png" alt="43" /></p><p>现在可以开始写算法</p><p>以下是一次光照</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/44.png" alt="44" /></p><p>递归就是全局光照</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/45.png" alt="45" /></p><p>但是光线数量会指数级暴增，因为递归一次是随机选择N个方向采样</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/46.png" alt="46" /></p><p>光线追踪是路径追踪，路径是指很多不同的单一路径，所以只发射一次</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/47.png" alt="47" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/48.png" alt="" /></p><p>增加停止条件，如果射中了物体，继续递归，如果射中了光源，停止递归</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/49.png" alt="49" /></p><p>但是真实世界中光线弹射是不会停止的，这样做会减少光线的弹射次数，会让场景损失很多能量</p><p>光线弹射三次场景亮度</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/50.png" alt="50" /></p><p>光线弹射十七次场景亮度</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/51.png" alt="51" /></p><h4 id="russian-roulette-rr">Russian Roulette (RR)</h4><p>限制弹射次数是不对，所以我们可以用俄罗斯轮盘赌来解决这个问题</p><p>俄罗斯轮盘赌的游戏中，左轮手一共可以装 6发子弹，我们装上4发子弹，然后开枪，有4/6的概率被射中，2/6的概率不射中活下来，我们可以用我们希望的概率来发射光线</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/52.png" alt="52" /></p><p>我们以一定的概率P往外发射一条光线，1-p的概率不发射光线，期望公式如上，概率乘于着色结果再除以概率，加上一减概率乘于没有追踪的结果零，如果命中概率就得到我们期望的着色值，如果没命中，就没有着色值，刚好获得我们需要的着色结果，因为总的获得光线能量的概率总和不超过1，分布是平均的，我们只需要设定一个合理的期望的概率</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/53.png" alt="53" /></p><p>算法如上，随机取值，如果小于于我们的概率，发射一条光线，获得结果后除以概率获得我们的期望结果</p><p>这就是一个完整的算法了！但是！还有一点小问题，因为我们是随机方向发射，场景中物体大小决定了有多大概率光线能击中物体(包括光源)，物体大被击中采样的概率大，物体小采样概率就小，有更多光线被浪费掉了，因此造成低采样率画面就会有噪声，高采样率就会比较干净，那么如何在低采样率下也能得到干净画面？</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/54.png" alt="54" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/55.png" alt="55" /></p><p>因此我们可以直接对光源采样，但是渲染方程是定义在立体角球面上的，我们想要对光源采样，可以将光源面积投影，dA光源一小块面积，dw球面一小块面积，dA投影到dw就有以下公式，直接对光源采样</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/56.png" alt="56" /></p><p>因此，来自光源的光线直接对光源采样，其他物体反射过来的光线我们还是按原来的方式随机采样，那么如何区分来自光源还是物体，哦我们只要在采样点直接连一条射线到光源，看中间是否有物体遮挡，有这事物体反射，没有就是来自光源</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/57.png" alt="57" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/58.png" alt="58" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/59.png" alt="59" /></p><p>到这里光线追踪就算全部完成，可以看出渲染结果和照片基本无差别</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/60.png" alt="60" /></p><p>最后贴下作业结果</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/haifuyun/haifuyun.github.io/main/_img/Graphics/RayTrac/61.png" alt="61" /></p><p>Path Trac-ing 算法</p><p>Code:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="c1">// Implementation of Path Tracing</span>
<span class="n">Vector3f</span> <span class="n">Scene</span><span class="o">::</span><span class="n">castRay</span><span class="p">(</span><span class="k">const</span> <span class="n">Ray</span> <span class="o">&amp;</span><span class="n">ray</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">pdf_light</span><span class="p">;</span>
    <span class="n">Intersection</span> <span class="n">lightInter</span><span class="p">;</span>     
    <span class="n">sampleLight</span><span class="p">(</span><span class="n">lightInter</span><span class="p">,</span><span class="n">pdf_light</span><span class="p">);</span>
    
    <span class="c1">// TO DO Implement Path Tracing Algorithm here</span>
    <span class="c1">//ray intersction</span>
    <span class="n">Intersection</span> <span class="n">inter</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">ray</span><span class="p">);</span>
    

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inter</span><span class="p">.</span><span class="n">happened</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
    <span class="p">}</span>
    

    <span class="k">if</span> <span class="p">(</span><span class="n">inter</span><span class="p">.</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">hasEmission</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">inter</span><span class="p">.</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">getEmission</span><span class="p">();</span>
    <span class="p">}</span>


    
    <span class="n">Vector3f</span> <span class="n">blockedCheckDir</span> <span class="o">=</span> <span class="n">lightInter</span><span class="p">.</span><span class="n">coords</span> <span class="o">-</span> <span class="n">inter</span><span class="p">.</span><span class="n">coords</span><span class="p">;</span>
    <span class="n">Intersection</span> <span class="n">blockCheckInter</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">Ray</span><span class="p">(</span><span class="n">inter</span><span class="p">.</span><span class="n">coords</span><span class="p">,</span><span class="n">blockedCheckDir</span><span class="p">.</span><span class="n">normalized</span><span class="p">()));</span>
    
    <span class="n">Vector3f</span> <span class="n">L_dir</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">blockCheckInter</span><span class="p">.</span><span class="n">coords</span> <span class="o">-</span> <span class="n">lightInter</span><span class="p">.</span><span class="n">coords</span><span class="p">).</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Vector3f</span> <span class="n">L_i</span> <span class="o">=</span>  <span class="n">lightInter</span><span class="p">.</span><span class="n">emit</span><span class="p">;</span>
        <span class="n">Vector3f</span> <span class="n">f_r</span> <span class="o">=</span> <span class="n">inter</span><span class="p">.</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span><span class="n">blockedCheckDir</span><span class="p">.</span><span class="n">normalized</span><span class="p">(),</span><span class="n">inter</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">cos_theta</span> <span class="o">=</span> <span class="n">dotProduct</span><span class="p">(</span><span class="n">blockedCheckDir</span><span class="p">.</span><span class="n">normalized</span><span class="p">(),</span> <span class="n">inter</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">cos_theta_Light</span> <span class="o">=</span> <span class="n">dotProduct</span><span class="p">(</span><span class="o">-</span><span class="n">blockedCheckDir</span><span class="p">.</span><span class="n">normalized</span><span class="p">(),</span><span class="n">lightInter</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">point_light_distance</span> <span class="o">=</span> <span class="n">dotProduct</span><span class="p">(</span><span class="n">blockedCheckDir</span><span class="p">,</span><span class="n">blockedCheckDir</span><span class="p">);</span>
        

        <span class="n">L_dir</span> <span class="o">=</span> <span class="n">L_i</span> <span class="o">*</span> <span class="n">f_r</span> <span class="o">*</span> <span class="n">cos_theta</span> <span class="o">*</span> <span class="n">cos_theta_Light</span> <span class="o">/</span> <span class="n">point_light_distance</span> <span class="o">/</span> <span class="n">pdf_light</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Vector3f</span> <span class="n">L_indir</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
    
    <span class="c1">//((float)rand() / (RAND_MAX))</span>
    <span class="kt">float</span> <span class="n">randomNumber</span> <span class="o">=</span> <span class="n">get_random_float</span><span class="p">();</span> 

    <span class="k">if</span> <span class="p">(</span><span class="n">randomNumber</span> <span class="o">&lt;</span> <span class="n">RussianRoulette</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Vector3f</span> <span class="n">wi</span> <span class="o">=</span> <span class="n">inter</span><span class="p">.</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">sample</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span><span class="n">inter</span><span class="p">.</span><span class="n">normal</span><span class="p">).</span><span class="n">normalized</span><span class="p">();</span>
        
        <span class="n">Vector3f</span> <span class="n">preL_dir</span> <span class="o">=</span> <span class="n">castRay</span><span class="p">(</span><span class="n">Ray</span><span class="p">(</span><span class="n">inter</span><span class="p">.</span><span class="n">coords</span><span class="p">,</span><span class="n">wi</span><span class="p">),</span><span class="n">depth</span><span class="p">);</span>
        <span class="n">Vector3f</span> <span class="n">indir_f_r</span> <span class="o">=</span> <span class="n">inter</span><span class="p">.</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">inter</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">indir_cos_theta</span> <span class="o">=</span> <span class="n">dotProduct</span><span class="p">(</span><span class="n">wi</span><span class="p">,</span> <span class="n">inter</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">indir_pdf</span> <span class="o">=</span> <span class="n">inter</span><span class="p">.</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">pdf</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span>  <span class="n">wi</span><span class="p">,</span> <span class="n">inter</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="n">L_indir</span> <span class="o">=</span> <span class="n">preL_dir</span> <span class="o">*</span> <span class="n">indir_f_r</span> <span class="o">*</span> <span class="n">indir_cos_theta</span> <span class="o">/</span> <span class="n">indir_pdf</span> <span class="o">/</span> <span class="n">RussianRoulette</span><span class="p">;</span> 
                
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">L_dir</span> <span class="o">+</span> <span class="n">L_indir</span><span class="p">;</span>
    

<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/haifuyun.github.io/categories/graphics/'>Graphics</a>, <a href='/haifuyun.github.io/categories/ray-tracing/'>Ray Tracing</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/haifuyun.github.io/tags/graphics/" class="post-tag no-text-decoration" >Graphics</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Computer Graphics Ray Tracing - Hi!FuYun&url=https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-RayTracing/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Computer Graphics Ray Tracing - Hi!FuYun&u=https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-RayTracing/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Computer Graphics Ray Tracing - Hi!FuYun&url=https://hifuyun.com/haifuyun.github.io/posts/Computer-Graphics-RayTracing/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/haifuyun.github.io/posts/Computer-Graphics-Visibility/">Computer Graphics Visibility</a><li><a href="/haifuyun.github.io/posts/Computer-Graphics-Shading/">Computer Graphics Shading</a><li><a href="/haifuyun.github.io/posts/Computer-Graphics-ShadingTexture/">Computer Graphics Shading Texture</a><li><a href="/haifuyun.github.io/posts/Computer-Graphics-Transformation/">Computer Graphics Transformation</a><li><a href="/haifuyun.github.io/posts/Computer-Graphics-Viewing-transformation/">Computer Graphics Viewing transformation</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/haifuyun.github.io/tags/graphics/">Graphics</a> <a class="post-tag" href="/haifuyun.github.io/tags/data-struct/">Data Struct</a> <a class="post-tag" href="/haifuyun.github.io/tags/ios/">iOS</a> <a class="post-tag" href="/haifuyun.github.io/tags/python/">Python</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/haifuyun.github.io/posts/Computer-Graphics-Transformation/"><div class="card-body"> <span class="timeago small" > Jun 17 <i class="unloaded">2021-06-17T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Computer Graphics Transformation</h3><div class="text-muted small"><p> 资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html 笛卡尔坐标系中，空间坐标的位置变换是通过矩阵相乘实现的. Linear Transforms = Matrices [\left [ \begin{matrix} x^{new} y^{new} \end{matrix} \right ] = \left...</p></div></div></a></div><div class="card"> <a href="/haifuyun.github.io/posts/Computer-Graphics-Viewing-transformation/"><div class="card-body"> <span class="timeago small" > Jun 18 <i class="unloaded">2021-06-18T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Computer Graphics Viewing transformation</h3><div class="text-muted small"><p> 资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html View / Camera Transformation 如何呈现一个画面？ Define the camera first 首先定义一个摄像机 Position (位置) \(\vec e\) Look-at / ga...</p></div></div></a></div><div class="card"> <a href="/haifuyun.github.io/posts/Computer-Graphics-Screen/"><div class="card-body"> <span class="timeago small" > Jun 19 <i class="unloaded">2021-06-19T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Computer Graphic Screen</h3><div class="text-muted small"><p> 资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html What’s after MVP? Model transformation (placing objects) View transformation (placing camera) View transformation (placing camera...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/haifuyun.github.io/posts/Computer-Graphics-ShadingTexture/" class="btn btn-outline-primary" prompt="Older"><p>Computer Graphics Shading Texture</p></a> <a href="/haifuyun.github.io/posts/%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E7%BB%98%E5%88%B6/" class="btn btn-outline-primary" prompt="Newer"><p>透明物体的绘制 - 混合与深度测试</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/haifuyun">haifuyun</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/haifuyun.github.io/tags/graphics/">Graphics</a> <a class="post-tag" href="/haifuyun.github.io/tags/data-struct/">Data Struct</a> <a class="post-tag" href="/haifuyun.github.io/tags/ios/">iOS</a> <a class="post-tag" href="/haifuyun.github.io/tags/python/">Python</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/haifuyun.github.io/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://hifuyun.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
