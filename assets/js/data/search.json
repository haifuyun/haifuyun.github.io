[ { "title": "Computer Graphics FlowMap", "url": "/haifuyun.github.io/posts/Computer-Graphics-FlowMap/", "categories": "Graphics, Texture Effect", "tags": "Graphics", "date": "2021-07-11 00:00:00 +0800", "snippet": "Flow map如字面意思，会流动的贴图，原理是采用两张贴图，一张展示底图，一张提供位置数据(Red、Green通道映射x、y位置)让底图采样得到位置数据叠加时间后产生位移效果，表现为流动效果提供位移数据的贴图分为RGBA四个通道，我们绘制RG两个通道，让他们分布在我们想要改变的位置坐标上底图叠加效果代码float4 f = tex2D(flowMap, i.uv) * 2 + 1;float4 t = tex2D(testTex, i.uv + f.xy * flowIntensity + float2(0, _Time.y * 0.1));return t;waterflowmap水..." }, { "title": "透明物体的绘制 - 混合与深度测试", "url": "/haifuyun.github.io/posts/%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E7%BB%98%E5%88%B6/", "categories": "Graphics, Blender", "tags": "Graphics", "date": "2021-07-10 00:00:00 +0800", "snippet": "透明物体的绘制 - 混合与深度测试当场景出现透明和不透明物体有前后遮挡关系时，我们要让透明物体透过自身能看到后面的不透明物体时，就需要混合两者的颜色，混合公式:混合源颜色与目标颜色Blend SrcFactor DstFactorSrcFactor 当前渲染的物体源颜色alpha值DstFactor 屏幕已渲染的像素底色alpha值混合公式，这里的目标颜色alpha值用时1-源颜色alpha，这个模式称为OneMinusSrcAlpha:SrcColorRGB　* SrcFactor + DstSrcColorRGB * （1 - SrcFactor）Z-buffer 深度缓冲区记录..." }, { "title": "Computer Graphics Ray Tracing", "url": "/haifuyun.github.io/posts/Computer-Graphics-RayTracing/", "categories": "Graphics, Ray Tracing", "tags": "Graphics", "date": "2021-06-28 00:00:00 +0800", "snippet": "光线追踪中需要用到几何的知识点，在这简单描述下涉及到的一些知识点Geometry表现几何的多种方法:Implicit(隐性)隐形几何方程可以表示空间中的一些点之间的关系，但是没有实际的点可以告诉你，方程如下:很容易可以判断某一个点是否在不在表面上: x = ? y = ? z = ?若f(x,y,z) &amp;lt; 1 在物体内若f(x,y,z) &amp;gt; 1 在物体外若f(x,y,z) = 1 在物体表面上\\[f(x,y,z) = x^2+y^2+z^2 = 1\\]Explicit(显性)定义一个函数，2D维度的贴图UV位置通过函数映射到3D维度坐标的面模型Ray Trac..." }, { "title": "Computer Graphics Shading Texture", "url": "/haifuyun.github.io/posts/Computer-Graphics-ShadingTexture/", "categories": "Graphics, Shading Texture", "tags": "Graphics", "date": "2021-06-24 00:00:00 +0800", "snippet": "资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html上一篇描述了着色的整体大概流程，这篇最后描述下着色最后一个环节，材质贴图映射的细节一张2D贴图纹理会映射到一个3D物体表面，3D物体表面的三维坐标是怎么映射到2D贴图的二维坐标的？使用重心坐标(Barycentric Coordinates)用三角形的三个顶点坐标进行内部坐标插值\\((x,y) = \\alpha A + \\beta B + \\gamma C\\)\\[\\alpha + \\beta + \\gamma = 1\\]\\[\\alpha、\\beta、\\gamma加起来..." }, { "title": "Computer Graphics Shading", "url": "/haifuyun.github.io/posts/Computer-Graphics-Shading/", "categories": "Graphics, Shading", "tags": "Graphics", "date": "2021-06-23 00:00:00 +0800", "snippet": "资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html在绘制像素后，我们要对其着色，着色模型使用Blinn-Phong Reflectance Model，着色的像素称点为shading point着色点需要使用到以下参数摄像机观察着色点方向，Viewer direction - v物体表面法线，Surface normal - n光照方向，Light direction - l物体表面参数，物体颜色、物体光泽度 ，color、shininess1.Diffuse Reflection光照射到物体表面然后被均匀的散射都各..." }, { "title": "Computer Graphics Visibility", "url": "/haifuyun.github.io/posts/Computer-Graphics-Visibility/", "categories": "Graphics, Visibility", "tags": "Graphics", "date": "2021-06-22 00:00:00 +0800", "snippet": "资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.htmlZ-buffering场景物体前后遮挡的关系Z-Buffer AlgorithmInitialize depth buffer to ∞ During rasterization:for (each triangle T) for (each sample (x,y,z) in T) if (z &amp;lt; zbuffer[x,y]) framebuffer[x,y] = rgb; zbuffer[x,y] = z; els..." }, { "title": "Computer Graphics Antialiasing", "url": "/haifuyun.github.io/posts/Computer-Graphics-Antialiasing/", "categories": "Graphics, Antialiasing", "tags": "Graphics", "date": "2021-06-21 00:00:00 +0800", "snippet": "资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.htmlAntialiasing抗锯齿原因：采样出现Artfacts(不准确的现象或结果)，在时域与频域上的解释是信号变化太快，以至于采样速度跟不上，用同样的采样方法，采样两种不同频率的函数信号，得出来的结果我们无法区分它，这就是频率上的走样.解决方法：在采样之前做模糊（低通滤波）滤波就是去掉一系列的频率，等于平均，等于卷积.Filtering = Convolution (= Averaging)低通滤波，过滤掉高频信息，采样重叠的信号（Artfacts）就会被去掉，再在用..." }, { "title": "Computer Graphic Screen", "url": "/haifuyun.github.io/posts/Computer-Graphics-Screen/", "categories": "Graphics, Screen", "tags": "Graphics", "date": "2021-06-19 00:00:00 +0800", "snippet": "资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.htmlWhat’s after MVP?Model transformation (placing objects)View transformation (placing camera)View transformation (placing camera)Projection transformation Orthographic projection (cuboid to “canonical” cube [-1, 1]3) Perspecti..." }, { "title": "Computer Graphics Viewing transformation", "url": "/haifuyun.github.io/posts/Computer-Graphics-Viewing-transformation/", "categories": "Graphics, Viewing transformation", "tags": "Graphics", "date": "2021-06-18 00:00:00 +0800", "snippet": "资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.htmlView / Camera Transformation如何呈现一个画面？Define the camera first首先定义一个摄像机 Position (位置)\\(\\vec e\\) Look-at / gaze direction (朝向物体方向)\\(gˆ\\) Up direction (顶上方向)\\(tˆ\\) 然后摄像机朝向物体当物体在空间中是随意摆放的，摄像机的位置和角度是随机不一样的我们为了标准化设置，我们将摄像机的..." }, { "title": "Computer Graphics Transformation", "url": "/haifuyun.github.io/posts/Computer-Graphics-Transformation/", "categories": "Graphics, Transformation", "tags": "Graphics", "date": "2021-06-17 00:00:00 +0800", "snippet": "资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html笛卡尔坐标系中，空间坐标的位置变换是通过矩阵相乘实现的.Linear Transforms = Matrices\\[\\left [\\begin{matrix}x^{new} \\\\y^{new}\\end{matrix}\\right ]=\\left [\\begin{matrix}a &amp;amp; b\\\\c &amp;amp; d\\end{matrix}\\right ]\\left [\\begin{matrix}x\\\\y\\end{matrix}\\right ]\\]\\[x..." }, { "title": "Computer Graphics Linear Algebra", "url": "/haifuyun.github.io/posts/Computer-Graphics-Linear-Algebra/", "categories": "Graphics, Linear Algebra", "tags": "Graphics", "date": "2021-06-16 00:00:00 +0800", "snippet": "资料来源：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html前段时间学习完成了Games101的计算机图形学入门课程作业，一直没抽时间回顾下知识点，所以以个人理解，写的精简点，用来回顾搜索。本篇以线性代数(Linear Algebra)基础知识点开始.Vectors(带方向的长度，指向)\\[\\vec a = \\overrightarrow{AB} = B - A\\]Magnitude (length(长度) - 向量也等于与自身点积的平方根)\\[\\begin{Vmatrix} \\vec a \\end{Vmatrix} = \\s..." }, { "title": "Unity shader and Compoent", "url": "/haifuyun.github.io/posts/Unity-shader-and-Compoent/", "categories": "Graphics, Unity", "tags": "Graphics", "date": "2018-05-04 00:00:00 +0800", "snippet": "Unity shader and CompoentUnityShader是Unity引擎提供的图形渲染框架，在上一篇博客里有详细的讲了Shader是用来干嘛的，UnityShader是对OpenGL、DIrectx两个底层图形渲染接口的封装，使用Unity自家的语言ShaderLab来编写, 因为提供了封装，所以写起来更加简便，省略了很多一些在GLSL、HLSL下编写代码中的繁琐重复的细节. 这里我们只讲Unity中的Vertex And Fragment Shader.UnityShader 内部结构 Shader Properties SubShader..." }, { "title": "LearnOpenGL", "url": "/haifuyun.github.io/posts/LearnOpenGL/", "categories": "Graphics, OpenGL", "tags": "Graphics", "date": "2018-01-08 00:00:00 +0800", "snippet": "LearnOpenGLOpenGL图形渲染接口 (Linux,Windows,MacOS,iOS,Android跨平台图形接口，底层库实现由显卡厂商(AMD NVIDIA)或系统厂商(APPLE)实现)渲染模式: Immediate mode OR Core-profileImmediate mode(已废弃):流水线固定渲染模式，这个模式下，所有步骤固定，只能控制整个过程中的一些阶段中一些功能的开启或者关闭Core-profile:核心模式，这个模式下，所有流程中的几个阶段不仅可以开启或者关闭，还可以自定义设置数据，比Immediate mode的编程自由性更强OpenGL 整个渲染过..." }, { "title": "Python 语法", "url": "/haifuyun.github.io/posts/Python-%E8%AF%AD%E6%B3%95/", "categories": "Python, Lang", "tags": "Python", "date": "2017-12-02 00:00:00 +0800", "snippet": "Python 语法数组索引a[start:end] # items start through end-1a[start:] # items start through the rest of the arraya[:end] # items from the beginning through end-1a[:] # a copy of the whole arraya[-1] # last item in the arraya[-2:] # last two items in the arraya[:-2] # everything except the last two items..." }, { "title": "Leet Code Problem", "url": "/haifuyun.github.io/posts/Leet-Code-Problem/", "categories": "Data Struct, LeetCode", "tags": "Data Struct", "date": "2017-09-29 00:00:00 +0800", "snippet": "Leet Code Problem412.Fizz BuzzWrite a program that outputs the string representation of numbers from 1 to n.But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”.For numbers which are multiples of both three and five output “FizzBuzz”..." }, { "title": "Xamarin 绑定iOS第三方库", "url": "/haifuyun.github.io/posts/Xamarin-%E7%BB%91%E5%AE%9AiOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/", "categories": "iOS, Xamarin", "tags": "iOS", "date": "2017-07-19 00:00:00 +0800", "snippet": "Xamarin 绑定iOS第三方库Xamarin iOS项目通常会需要用到一些第三方库，如AFNetworking、SDWebImage等，这些库源代码都是用Objective-c写的，因此我们就需要将Objective-C代码API转换成C#代码API来使用。接下来我们根据Xamrain的官方文档里面的几篇文章来绑定绑定一个Objective-c库用于Xamarin需要三个步骤:1.编写一个C#的“API definition”.cs文件去描述原生API在.NET中的暴露方式，以及c#是怎么映射到底层Objective-c. 这里使用C#结构体像interface和各种属性来完成2.一..." }, { "title": "算法时间空间复杂度", "url": "/haifuyun.github.io/posts/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/", "categories": "Data Struct, Time Space Complexity", "tags": "Data Struct", "date": "2017-04-16 00:00:00 +0800", "snippet": "算法时间空间复杂度原文资料：CMU 15-112: Fundamentals of Programming and Computer Science Class Notes: Efficiency1.Big-Oh video 1.描述函数的渐进行为 2.非正式解释 (for 15112): 忽略所有低阶项和常量级 3.正式解释 (after 15112): 维基百科 4.一些例子: 3n^2 - 2n + 25 is O(n^2) 30000n^2 + 2n - 25 is O(n^2) 0.00000000001n^2 + 123456789n is ..." } ]
